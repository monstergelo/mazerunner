#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Tree.h"
int node_id;
int current_node;
int back;
//fungsi=======================================================
//listPsudo--------------------------------------------------
void Add_Anak(int Id, int L, int M, int R)
/*Menambahkan anak kiri, kanan, dan tengah ke sebuah node Id,
*/
{
	setLeft(&mem[Id], L);
	setMid(&mem[Id], M);
	setRight(&mem[Id], R);
}

int Aloc(int Id, int Pa)
/* Menghasilkan sebuah node Id, dengan parent Pa. Node tidak punya anak.
	Mengembalikan id node.
*/
{
	setId(&mem[Id], Id);
	setParent(&mem[Id], Pa);
	return Id;
}

//bergerak memutar balik robot
void putarBalik()
{
	Pop();
	back = 1;
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 50);
	sleep(1500);
}

void putarKembali()
{
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 50);
	sleep(1500);
}

//stackPsudo----------------------------------------------------------------
void Push(int i)
{
	sMem.data[sMem.top].Id = i;
	sMem.top = (sMem.top) + 1;
}

int Pop()
{
	sMem.top= (sMem.top) - 1;
	return sMem.data[sMem.top].Id;
}

void backStep()
{
	int jalan = Pop();
//0, kiri
//1, lurus
//2, kanan
	if(jalan == 2)
	{
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 50);
		sleep(1000);
	}
	else if(jalan == 1)
	{
		setMotorSpeed(leftMotor, 61);
		setMotorSpeed(rightMotor, 60);
		sleep(650);
	}
	else if(jalan == 0)
	{
		setMotorSpeed(leftMotor, 60);
		setMotorSpeed(rightMotor, 27);
		sleep(1000);
	}
	else
	{
		setMotorSpeed(leftMotor, 600);
		setMotorSpeed(rightMotor, 0);
		sleep(100000);
	}
}

//cariJalan******************************************************************
//gerak mengikuti garis hitam
void maju()
{
	float temp = (float) getColorReflected(colorSensor) *3/5  + 20;

	if(getColorReflected(colorSensor) >= 95)
	{
		motor[rightMotor]  = 40;
		motor[leftMotor] = 0;
		sleep(500);
	}
	else
	{
		motor[leftMotor]  =  30 + temp;
		motor[rightMotor] =  30 + 60 - temp;
	}
}

void gerak()
{
	repeat(forever)
	{
		if(getColorName(colorSensor)==colorBlue)
		{
			break;
		}
		else if(getColorName(colorSensor)==colorGreen)
		{
			if (back == 0){
				Next_Node_Parent();
			}
			else {
				Next_Node();
				back = 0;
			}
		}
		else if(getColorName(colorSensor)==colorRed)
		{
			putarBalik();
		}
		else //warna item
		{
			maju();
		}
	}
}

void gerakKembali()
{
	putarKembali();
	repeat(forever)
	{
		if(getColorName(colorSensor)==colorBlue)
		{
			break;
		}
		else if(getColorName(colorSensor)==colorGreen)
		{
			backStep();
		}
		else if(getColorName(colorSensor)==colorRed)
		{
			break;
		}
		else //warna item
		{
			maju();
		}
	}
}

//cek apakah ada jalan lurus
bool cekLurus()
{
	bool is_node = false;
	setMotorSpeed(leftMotor, 61);
	setMotorSpeed(rightMotor, 60);
	sleep(680);
	if(getColorName(colorSensor)==colorBlack)
	{
		is_node = true;
	}
	return is_node;
}

//cek apakah ada jalan kanan
bool cekKanan()
{
	bool is_node = false;
	setMotorSpeed(leftMotor, 60);
	setMotorSpeed(rightMotor, 29);
	sleep(1000);
	if(getColorName(colorSensor)==colorBlack)
	{
		is_node = true;
	}
	return is_node;
}

//cek apakah ada jalan kiri
bool cekKiri()
{
	bool is_node = false;
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 50);
	sleep(1000);
	if(getColorName(colorSensor)==colorBlack)
	{
		is_node = true;
	}
	return is_node;
}

//Robot sudah menyusuri sebuah jalur namun belum bertemu solusi
// lalu balik lagi ke persimpangan sebelumnya. Prosedur void memberitahu robot
// Node mana lagi yang perlu dijalankan. Jika anak kanan sudah, maka selanjutnya lurus,
//Jika lurus sudah maka selanjutnya anak kiri.
void Next_Node() {
	int prev_node = current_node;
	current_node = mem[current_node].Parent;
	int Kanan = -1, Kiri = -1, Lurus = -1;
	if (prev_node == mem[current_node].Right) {
		if (cekKanan()) {
			Push(1);
			Lurus = Aloc(node_id, current_node);
			Add_Anak(current_node, Kiri, Lurus, Kanan);
			current_node = mem[current_node].Mid;
			node_id++;
			}
		else {
			setMotorSpeed(leftMotor, -58);
			setMotorSpeed(rightMotor, -29);
			sleep(1000);

			if (cekLurus()) {
			Push(0);
			Kiri = Aloc(node_id, current_node);
			Add_Anak(current_node, Kiri, Lurus, Kanan);
			current_node = mem[current_node].Left;
			node_id++;
			}
			else {
				if (cekKiri()) {
					Pop();
					back = 1;
				}
			}
		}
	}
	else if (prev_node == mem[current_node].Mid) {
		if (cekKanan()) {
			Push(0);
			Kiri = Aloc(node_id, current_node);
			Add_Anak(current_node, Kiri, Lurus, Kanan);
			current_node = mem[current_node].Mid;
			node_id++;
			}
			else {
				setMotorSpeed(leftMotor, -60);
				setMotorSpeed(rightMotor, -29);
				sleep(1000);

				if (cekLurus()) {
						Pop();
						back = 1;
				}
			}
	}
	else if (cekKanan()) {
						Pop();
						back = 1;
	}
}

void Next_Node_Parent() {
	int Kanan = -1, Kiri = -1, Lurus = -1;
	if (cekKanan()) {
		Push(2);
		Kanan = Aloc(node_id, current_node);
		Add_Anak(current_node, Kiri, Lurus, Kanan);
		current_node = mem[current_node].Right;
		node_id++;
	}
	else {
		setMotorSpeed(leftMotor, -60);
		setMotorSpeed(rightMotor, -30);
		sleep(1000);

		if (cekLurus()) {
		Push(1);
		Lurus = Aloc(node_id, current_node);
		Add_Anak(current_node, Kiri, Lurus, Kanan);
		current_node = mem[current_node].Mid;
		node_id++;
		}
		else {
			setMotorSpeed(leftMotor, -60);
			setMotorSpeed(rightMotor, -60);
			sleep(1000);

			if (cekKiri()) {
			Push(0);
			Kiri = Aloc(node_id, current_node);
			Add_Anak(current_node, Kiri, Lurus, Kanan);
			current_node = mem[current_node].Left;
			node_id++;
			}
			else {
				setMotorSpeed(leftMotor, 0);
				setMotorSpeed(rightMotor, -55);
				sleep(1000);
			}
		}
	}
	//tidak punya node kanan, langsung lurus
}

task main()
{
	for(int index=0; index<16; index++)
	{
		sMem.data[index].Id = 999;
	}
	sMem.data[0].Id = 999;
	sMem.top = 1;
	node_id = 0;
	current_node = 0;
	back = 0;
	int i;
	for (i = 0; i < 100; i++) {
		mem[i].Id = -1;
		mem[i].Left = -1;
		mem[i].Mid = -1;
		mem[i].Right = -1;
		mem[i].Parent = -1;
	}

	//maju dikit biar kaga kena bir
	//setMotorSpeed(leftMotor, wna
	gerak();
	gerakKembali();
}
