#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Tree.h"
//alamat memori kosong yg dapat dialokasi
int node_id;
//alamat stack tersedia
int stack_id;

//Node tempat robot sekarang
int current_node;

//Bernilai 0 jika robot balik arah, dan sebaliknya
int is_mundur;

//Batas kedalaman penelusuran
int batas_kedalaman;

//Kedalaman robot sekarang (tree)
int kedalaman;

//Alamat node root (akar)
int root;

//
int cabang;
// OPERASI TREE=======================================================
void Add_Anak_Kanan(int Id, int A)
{
	setRight(&mem[Id], A);
}
void Add_Anak_Lurus(int Id, int A) {
	setMid(&mem[Id], A);
}
void Add_Anak_Kiri(int Id, int A) {
	setLeft(&mem[Id], A);
}
int Aloc(int Id, int Pa)
/* Menghasilkan sebuah node Id, dengan parent Pa. Node tidak punya anak.
	Mengembalikan id node.
*/
{
	setId(&mem[Id], Id);
	setParent(&mem[Id], Pa);
	mem[Id].On = 1;
	return Id;
}

void push(int i, int t) {
	stack[stack_id].Id = i;
	stack[stack_id].Turn = t;
	stack_id++;
}

void pop() {
	stack_id--;
	stack[stack_id].Id = -1;
	stack[stack_id].Turn = -1;
}

//bergerak memutar balik robot
void putarBalik()
{
	is_mundur = 1;
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 50);
	sleep(1500);
	kedalaman = kedalaman - 1;
}

//gerak mengikuti garis hitam
void maju()
{
	float temp = (float) getColorReflected(colorSensor) *3/5  + 20;

	if(getColorReflected(colorSensor) >= 96)
	{
		motor[rightMotor]  = 30;
		motor[leftMotor] = -20;
		sleep(300);
	}
	else
	{
		motor[leftMotor]  =  40 + temp;
		motor[rightMotor] =  40 + 60 - temp;
	}
}

//cariJalan******************************************************************

void gerak()
{
	repeat(forever)
	{
		if(getColorName(colorSensor)==colorBlue)
		{
			Pulang();
			break;
		}
		else if(getColorName(colorSensor)==colorGreen)
		{
			if (is_mundur == 0){
				if (kedalaman < batas_kedalaman ) {
					Next_Node_Root();
				}
				else {
					putarBalik();
				}
			}
			else {
				is_mundur = 0;
				Next_Node();
			}

		}
		else if(getColorName(colorSensor)==colorRed)
		{
			putarBalik();
			mem[current_node].On = 0;
			kill_node();
		}
		else //warna item
		{
			maju();
		}
		sleep(50);
	}
}

//Sudah tidak ada lagi anak yg bisa ditelusuri pada current_node,
//robotc kembali ke simpul sebelumnya (parent(current_node))
void backtrack () {

}

void kill_node() {
	int P = mem[current_node].Parent;
	if (Turn(stack_id) == 1) {
		mem[P].Right = 0;
	}
	else if (Turn(stack_id) == 2) {
		mem[P].Mid = 0;
	}
	else if (Turn(stack_id) == 3) {
		mem[P].Left = 0;
	}
}

//cek apakah ada jalan lurus
bool cekLurus()
{
	bool is_node = false;
	setMotorSpeed(leftMotor, 64);
	setMotorSpeed(rightMotor, 60);
	sleep(700);
	if(getColorName(colorSensor)==colorBlack)
	{
		is_node = true;
	}
	return is_node;
}

//cek apakah ada jalan kanan
bool cekKanan()
{
	bool is_node = false;
	setMotorSpeed(leftMotor, 60);
	setMotorSpeed(rightMotor, 28);
	sleep(1000);
	if(getColorName(colorSensor)==colorBlack)
	{
		is_node = true;
	}
	return is_node;
}

//cek apakah ada jalan kiri
bool cekKiri()
{
	bool is_node = false;
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 50);
	sleep(1000);
	if(getColorName(colorSensor)==colorBlack)
	{
		is_node = true;
	}
	return is_node;
}

void free_mem() {
	int i;
		for (i = 0; i < 100; i++) {
		mem[i].Id = -1;
		mem[i].Left = -1;
		mem[i].Mid = -1;
		mem[i].Right = -1;
		mem[i].Parent = -1;
	}
}

//Robot sudah menyusuri sebuah jalur namun belum bertemu solusi
// lalu balik lagi ke persimpangan sebelumnya. Prosedur void memberitahu robot
// Node mana lagi yang perlu dijalankan. Jika anak kanan sudah, maka selanjutnya lurus,
//Jika lurus sudah maka selanjutnya anak kiri.
void Next_Node() {
	current_node = Parent(current_node);
	int Kiri = -1, Lurus = -1;
	if (Turn(stack_id) == 1){
		pop();
		if (mem[current_node].Mid != 0 && cekKanan()) {
			if (mem[current_node].Mid == -1) {
				Lurus = Aloc(node_id, current_node);
				Add_Anak_Lurus(current_node, Lurus);
				node_id++;
			}
			kedalaman+=1;
			current_node = mem[current_node].Mid;
			push(current_node, 2);
		}
			else {
				if (mem[current_node].Mid != 0) {//&& !cekKanan
					mem[current_node].Mid = 0;
					setMotorSpeed(leftMotor, -60);
					setMotorSpeed(rightMotor, -30);
					sleep(1000);
				}

				if (mem[current_node].Left != 0 && cekLurus()) {
					if (mem[current_node].Left == -1) {
						Kiri = Aloc(node_id, current_node);
						Add_Anak_Kiri(current_node, Kiri);
						node_id++;
					}
					kedalaman+=1;
					current_node = mem[current_node].Left;
					push(current_node, 3);
				}
				else {
					if (current_node == root) {
						cabang = 0;
						batas_kedalaman += 1;
						setMotorSpeed(leftMotor, 50);
						setMotorSpeed(rightMotor, 0);
						sleep(700);
						setMotorSpeed(leftMotor, -50);
						setMotorSpeed(rightMotor, -50);
						sleep(1000);
						is_mundur = 0;
					}
					else if (cekKiri()){
						is_mundur = 1;
						kedalaman -=1;
					}
				}
			}

	}
	else if (Turn(stack_id) == 2) {
		pop();
		if (mem[current_node].Left != 0 && cekKanan()) {
			if (mem[current_node].Left == -1) {
				Kiri = Aloc(node_id, current_node);
				Add_Anak_Kiri(current_node, Kiri);
				node_id++;
			}
			kedalaman += 1;
			current_node = mem[current_node].Left;
			push(current_node, 3);
		}
			else {
				if (mem[current_node].Left != 0) {
					mem[current_node].Left = 0;
					setMotorSpeed(leftMotor, -60);
					setMotorSpeed(rightMotor, -29);
					sleep(1000);
				}

				if (current_node == root) {
					batas_kedalaman += 1;
					cabang = 0;
					setMotorSpeed(leftMotor, 50);
					setMotorSpeed(rightMotor,50);
					sleep(2000);
					setMotorSpeed(leftMotor, 50);
					setMotorSpeed(rightMotor, 10);
					sleep(1700);
					is_mundur = 0;
				}
				else if (cekLurus()){
					is_mundur = 1;
					kedalaman -=1;
				}
			}
	}
	else {
		pop();
		if (current_node == root) {
			batas_kedalaman += 1;
				setMotorSpeed(leftMotor, 10);
				setMotorSpeed(rightMotor, 52);
				sleep(850);
				setMotorSpeed(leftMotor, -50);
				setMotorSpeed(rightMotor, -50);
				sleep(2000);
				is_mundur = 0;
		}
		else if (cekKanan()){
			is_mundur = 1;
			kedalaman -=1;
		}
	}
}

void Next_Node_Root() {
	is_mundur = 0;
	int Kanan = -1, Kiri = -1, Lurus = -1;
	if (Right(current_node) != 0 && cekKanan()) {
		if (Right(current_node) == -1) {
			Kanan = Aloc(node_id, current_node);
			Add_Anak_Kanan(current_node, Kanan);
			node_id++;
		}
		kedalaman += 1;
		current_node = Right(current_node);
		push(current_node, 1);
	}
	else {
		if (Right(current_node) != 0){
			mem[current_node].Right = 0;
			setMotorSpeed(leftMotor, -60);
			setMotorSpeed(rightMotor, -30);
			sleep(1000);
		}
		if (Mid(current_node) != 0 && cekLurus()) {
			if (Mid(current_node) == -1) {
				Lurus = Aloc(node_id, current_node);
				Add_Anak_Lurus(current_node, Lurus);
				node_id++;
			}
			kedalaman += 1;
			current_node = Mid(current_node);
			push(current_node, 2);
		}
		else {
			if (Mid(current_node) != 0) {
				mem[current_node].Mid = 0;
				setMotorSpeed(leftMotor, -50);
				setMotorSpeed(rightMotor, -50);
				sleep(1000);
			}

			if (Left(current_node) != 0 && cekKiri()) {
				if (Left(current_node) == -1) {
					Kiri = Aloc(node_id, current_node);
					Add_Anak_Kiri(current_node, Kiri);
					node_id++;
				}
				kedalaman += 1;
				current_node = Left(current_node);
				push(current_node, 3);
			}
			else {
				mem[current_node].Left = 0;
				setMotorSpeed(leftMotor, 0);
				setMotorSpeed(rightMotor, 0);
				sleep(2000);
				putarBalik();
			}
		}
	}
	//tidak punya node kanan, langsung lurus
}

void Pulang() {
	putarBalik();
	repeat(forever)
	{
		if(getColorName(colorSensor)==colorBlue)
		{
			break;
		}
		else if(getColorName(colorSensor)==colorGreen)
		{
				if (Turn(stack_id) == 1) {
					cekKiri();
					pop();
				}
				else if (Turn(stack_id) == 2) {
					cekLurus();
					pop();
				}
				else 	if (Turn(stack_id) == 3) {
					cekKanan();
					pop();
				}

		}
		else //warna item
		{
			maju();
		}
	}
}

task main()
{
	cabang = 0;
	node_id = 1;
	stack_id = 1;
	current_node = 1;
	is_mundur = 0;
	batas_kedalaman = 2;
	kedalaman  = 1;
	root = 1;
	//Inisialisasi
	int i;
	for (i = 0; i < 100; i++) {
		mem[i].Id = -1;
		mem[i].Left = -1;
		mem[i].Mid = -1;
		mem[i].Right = -1;
		mem[i].Parent = -1;
		mem[i].On = 0;
	}
	for (i = 0; i < 100; i++) {
		stack[i].Id = -1;
		stack[i].Turn = -1;
	}
	//maju dikit biar kaga kena bir
	//setMotorSpeed(leftMotor, 50);
	//setMotorSpeed(rightMotor, 50);
	//sleep(3000);
	//belok dikit
	//setMotorSpeed(rightMotor, 50);
	//setMotorSpeed(leftMotor, 0);
	//sleep(300);

	current_node = Aloc(node_id, 0);
	node_id++;
	push(current_node, 0);
	//mulai algoritma gerak warna
	gerak();
}
